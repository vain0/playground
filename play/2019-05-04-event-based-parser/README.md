# Event-based Parser

イベント型のパーサーの実装の練習

## モチベーション

構文解析と解析結果の処理を分離すること。

## 単純な例

例えば `1+2` という式がある。これを字句解析してトークンに分割する。

トークンのリストをパースして、以下のようなイベントのリストを生成するように、パーサーを実装する。この実装は、典型的な再帰下降構文解析とそれほど変わらない。

```
START(RootExp)
    START(BinExp)
        START(LitExp)
            TOKEN(IntToken) '1'
        END(Some(LitExp))
        TOKEN(PlusToken) '+'
        START(LitExp)
            TOKEN(IntToken) '2'
        END(Some(LitExp))
    END(Some(BinExp))
END(Some(RootExp))
```

(インデントは START-END の対応を強調しているだけなので、無視していい。)

このようなイベントのリストは汎用性がある。例えば以下のような使い道が考えられる。

- 抽象構文木を作る。START/END イベントをそれぞれスタックの push/pop に対応させれば容易にできる。
- 具象構文木を作る。トークンに周辺の空白やコメントの情報を持たせればいい。
- テキスト形式でシリアライズする。ファイルに保存しておけばスナップショットテストに使える。

## イベントの順番の変更 (forward_parent/precede)

上記の START(BinExp) (二項演算子の開始を表すイベント) を発行する位置はかなり微妙である。というのも、`1 + 2` において `1` より先に `+` を見なければいけない。

参考にしたコードでは、`+` を見た時点で「左辺 (`1`) の直前に二項演算式の開始イベントを挟む」ようにするという方法をとっている。(`parser.rs` を参照。) パースが終わった後にイベントの順番を適切に入れ替えればいい。

## その他のトピック

- エラー回復
- 具象構文木の組み立て

## 参考

<https://github.com/rust-analyzer/rust-analyzer>/crates/{ra_parser, ra_syntax}

- ra_parser はパーサーの実装 (コメントでイベントの仕組みについて説明が書かれている)
- ra_syntax はパーサーを使って具象構文木を組み立てている
