# Rustでローカル無名再帰してみた

クロージャを再帰呼び出しする方法を考えました。

競技プログラミングではローカル変数を書き換えながら再帰する処理がよく出てきます。しかし Rust でそれを書こうとするとやや冗長になりがちです。

本稿は小さなヘルパーを用意して記述を簡略化することを試みた記録です。

- 環境: Rust 1.15.1 (AtCoder での現在のバージョン)

## 要約

- 競プロではよくローカルで無名再帰する
- 小さなアダプタを書くと再帰呼び出しできる
- イミュータブルなクロージャはローカル変数を書き換えられない
    - `RefCell` で対処する
- ミュータブルなクロージャの再帰呼び出しは借用ルールに抵触する
    - `unsafe` で解決する

## 用例1: 階乗

単純な例として、階乗の計算を再帰で書けるようにしましょう。内部で自身を参照するために、クロージャは引数に `fact` (階乗関数) を受け取るようにする方針でいきます。

```rust
    let fact_5 = recurse(5, &|n, fact| {
        if n <= 1 {
            1_i64
        } else {
            n * fact(n - 1)
        }
    });
    assert_eq!(1 * 2 * 3 * 4 * 5, fact_5);
```

ここで ``recurse(x, f)`` が ``f(x, f)`` の意味になるように後で定義するヘルパーです。

「なぜ作った関数を即座に起動するのか」という疑問があると思いますが、それは実際にそういう用途が多いからです。再帰関数がほしいときは ``|x| recurse(x, &|x, f| ..)`` のようにクロージャ化する運用でも大丈夫でしょう。

## 実装1: イミュータブル版

`recurse` の実装は簡単で、`fn` で定義した関数が再帰可能であることを利用します。

```rust
    fn recurse<X, Y>(x: X, f: &Fn(X, &Fn(X) -> Y) -> Y) -> Y {
        f(x, &|x: X| recurse(x, &f))
    }
```

注意点は、クロージャの引数の型がまたそのクロージャの型で……という無限再帰を避けるため、関数をトレイトオブジェクトへの参照という形で扱っていることです。

``Fn(X) -> Y`` というのは「型 `X` の値を受け取って型 `Y` の値を返す関数」の型を表すトレイトで、ある種のクロージャの型は自動的に `Fn` を実装しています。参照: [std::ops::Fn - Rust](https://doc.rust-lang.org/std/ops/trait.Fn.html)

    &Fn(X, &Fn(X) -> Y) -> Y
            ^^^^^^^^^^           再帰関数の型 (クロージャの引数)
     ^^^^^^^^^^^^^^^^^^^^^^^     定義したクロージャのトレイトオブジェクトの型

## 用例2: DFSで連結成分分解

次に現実的な例として、グラフの連結成分分解を深さ優先探索で書いてみます。

```rust
    //
    //   0 -- 1
    //   | \
    //   |  \
    //   2 -- 3    4--5
    //
    let graph =
        vec![
            vec![1, 2, 3],
            vec![0],
            vec![0, 3],
            vec![0, 2],
            vec![5],
            vec![4],
        ];
    let n = graph.len();

    let roots = RefCell::new(vec![n; n]);
    for u in 0..n {
        recurse(u, &|v, go| {
            if roots.borrow()[v] < n {
                return;
            }

            roots.borrow_mut()[v] = u;

            for &w in graph[v].iter() {
                go(w);
            }
        })
    }

    assert_eq!(&*roots.borrow(), &[0, 0, 0, 0, 4, 4]);
```

頂点 `v` が属す連結成分の代表を ``roots[v]`` に入れていきます。

このとき、再帰の途中で配列を更新する必要がありますが、もし `roots` を let **mut** で宣言していたら、先ほどの `recurse` は使えません。というもの、外部のミュータブルな変数を借用するクロージャは `Fn` トレイトを実装しないからです。

ここでは `RefCell` でラップすることにより、この問題を回避しています。クロージャに渡すのが `RefCell` へのイミュータブルな参照でも、内部の値をミュータブルとして扱えます。

なんにせよ、これで晴れてローカル無名再帰ができました！ **バンザイ！**

## 実装2. ミュータブル版

記述量を減らすのが目的なので、 `RefCell` をなくす方法も考えてみます。

そもそもクロージャの型が自動で実装する、関数型のためのトレイトは `Fn` のほかに `FnMut` もあります。

`FnMut` は、簡単にいうと「ミュータブルな状態を持つ関数」の型が実装すべきトレイトです。参照: [std::ops::FnMut - Rust](https://doc.rust-lang.org/std/ops/trait.FnMut.html)

外部のミュータブルな状態 (例えば ``let mut roots = ...``) を触りながら `recurse` できるように、クロージャに `FnMut` でもいいようにしてみます。すると、借用検査が **通りません** 。

通せるようにしたのが以下です:

```rust
fn recurse<X, Y>(x: X, f: &mut FnMut(X, &mut FnMut(X) -> Y) -> Y) -> Y {
    let fp = f as *mut FnMut(X, &mut FnMut(X) -> Y) -> Y;
    let f1 = unsafe { &mut *fp };
    let f2 = unsafe { &mut *fp };
    f1(x, &mut |x: X| recurse(x, f2))
}
```

これをみると分かるように、 `recurse` は受け取ったクロージャへの参照を2つ複製します: 即座に呼び出すための参照と、再帰用に呼び出すための参照です。ミュータブルな参照は複製できないので、`unsafe` を使って強制的に複製しています。

これでDFSを書き直すと、見事に `RefCell` が消失してすっきり。

```rust
        let mut roots = vec![n; n];
        for u in 0..n {
            recurse(u, &mut |v, go| {
                if roots[v] < n {
                    return;
                }

                roots[v] = u;

                for &w in graph[v].iter() {
                    go(w);
                }
            })
        }
```

## 参考

- [Stebalien commented on 28 Jan 2016](https://github.com/Hoverbear/rust-rosetta/issues/450#issuecomment-175848086)

    Zコンビネータを使ってクロージャを再帰可能にするコードの例。関数の型が推論されにくい。
