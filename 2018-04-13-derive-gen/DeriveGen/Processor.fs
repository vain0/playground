module DeriveGen.Processor

open System
open Chiron
open Chiron.Inference

module CD = Chiron.Decoder
module JD = Json.Decode
module JE = Json.Encode

let templateSource = """/// <auto-generated />

using System;
{%- for u in Model.Usings -%}
using {{ u }};
{%- endfor -%}
using Dgh = DeriveGen.Internals.Helper;

namespace DeriveGen.Internals
{
    internal static class Helper
    {
        public static int Hash<T>(T value)
        {
            return System.Collections.Generic.EqualityComparer<T>.Default.GetHashCode(value);
        }
    }
}
{%- for ns in Model.Namespaces -%}

namespace {{ ns.NamespaceName }}
{
    {%- for class in ns.Classes -%}
    {%- if class != ns.Classes.first -%}

    {%- endif -%}
    {{ class.Modifiers | join: " " }} {{ class.Kind.Keyword }} {{ class.ClassName }}
    {%- if class.BaseType != nil -%}
        : {{ class.BaseType.Value }}
    {%- endif -%}
    {
        {%- for field in class.Fields -%}
        {{ field.Modifiers | join: " " }} {{ field.Type }} {{ field.FieldName }} {{- field.AutoAccessors }};
        {%- endfor -%}
        {%- for method in class.Methods -%}

        {%- if method.Parameters.size >= 3 -%}
        {{ method.Modifiers | join: " " }} {{ method.Type }}{% if method.MethodName != "" %} {{ method.MethodName }}{% endif %}(
            {%- for parameter in method.Parameters -%}
            {{ parameter.Type }} {{ parameter.ParameterName }} {%- if parameter != method.Parameters.last %},{% endif %}
            {%- endfor -%}
        )
        {%- else -%}
        {{ method.Modifiers | join: " " }} {{ method.Type }}{% if method.MethodName != "" %} {{ method.MethodName }}{% endif %}({%- for parameter in method.Parameters -%}{{ parameter.Type }} {{ parameter.ParameterName }} {%- if parameter != method.Parameters.last %}, {% endif %}{%- endfor -%})
        {%- endif -%}
        {
            {%- for statement in method.Statements -%}
            {{ statement }}
            {%- endfor -%}
        }
        {%- endfor -%}
    }
    {%- endfor -%}
}
{%- endfor -%}
"""

type DotLiquidHelper =
  static member CreateHash() =
    let warn (self: DotLiquid.Hash) name =
      failwithf "Field '%s' missing in env [%s]."
        name
        (self.Keys |> String.concat ";")
    DotLiquid.Hash(lambda = Func<_, _, _>(warn))

  static member HashFromJson(j: string) =
    let rec decode =
      function
      | Json.Null ->
        null :> obj
      | Json.True ->
        true :> obj
      | Json.False ->
        false :> obj
      | Json.Number number ->
        Double.Parse(number) :> obj
      | Json.String string ->
        string :> obj
      | Json.Array array ->
        array
        |> Seq.map decode
        |> Seq.toArray
        |> box
      | Json.Object obj ->
        let hash = DotLiquidHelper.CreateHash()
        for KeyValue (key, value) in obj |> JsonObject.toMap do
          hash.Add(key, decode value)
        hash |> box
    Json.parse j
    |> JsonResult.map decode
    |> JsonResult.getOrThrow

  static member LocalFromJson(j: string) =
    let hash = DotLiquidHelper.CreateHash()
    hash.Add("Model", DotLiquidHelper.HashFromJson(j))
    hash

module CodeGeneration =

  type Identifier = string
  type Modifier = string

  type TypeKind =
    | Class
    | Struct
  with
    member this.Keyword =
      match this with
      | Class -> "class"
      | Struct -> "struct"

  type FieldModel =
    {
      FieldName: Identifier
      Type: string
      Modifiers: Modifier[]
    }

  type ParameterModel =
    {
      ParameterName: Identifier
      Type: string
    }

  type MethodModel =
    {
      MethodName: Identifier
      Type: string
      Modifiers: Modifier[]
      Parameters: ParameterModel[]
      Statements: string[]
    }

  type ClassModel =
    {
      ClassName: Identifier
      Kind: TypeKind
      Modifiers: Modifier[]
      BaseType: option<Identifier>
      Fields: FieldModel[]
      Methods: MethodModel[]
    }

  type NamespaceModel =
    {
      NamespaceName: Identifier
      Classes: ClassModel[]
    }

  type ModuleModel =
    {
      Usings: string[]
      Namespaces: NamespaceModel[]
    }
  with
    member this.ToJson() =
      let data = Utf8Json.JsonSerializer.Serialize(this)
      Utf8Json.JsonSerializer.PrettyPrint(data)

  module Identifier =
    let toLowerCamelCase (ident: string) =
      if ident.Length = 0 then
        ident
      else if Char.ToLower(ident.[0]) = Char.ToUpper(ident.[0]) then
        "_" + ident
      else
        (Char.ToLower(ident.[0]) |> string) + ident.Substring(1)

  let generateCompleteConstructor className fields =
    let parameters =
      [|
        for field in fields ->
          {
            ParameterName = field.FieldName |> Identifier.toLowerCamelCase
            Type = field.Type
          }
      |]
    let statements =
      [|
        for field in fields do
          let parameterName = field.FieldName |> Identifier.toLowerCamelCase
          yield sprintf "%s = %s;" field.FieldName parameterName
      |]
    {
      MethodName = ""
      Modifiers = [|"public"|]
      Type = className
      Parameters = parameters
      Statements = statements
    }

  let generateToString selfType fields =
    [|
      let param name ty = { ParameterName = name; Type = ty }
      // ToString()
      yield {
        MethodName = "ToString"
        Modifiers = [|"public"; "override"|]
        Type = "string"
        Parameters = [||]
        Statements =
          [|
            yield sprintf "return new System.Text.StringBuilder().Append(\"%s {\")" selfType
            for (i, field) in fields |> Seq.indexed do
              let comma = if i = 0 then "" else ", "
              yield sprintf """    .Append("%s\"%s\": ").Append(%s)""" comma field.FieldName field.FieldName
            yield """    .Append("}").ToString();"""
          |]
      }
    |]

  let generateEquality selfType typeKind fields =
    [|
      let param name ty = { ParameterName = name; Type = ty }
      // Equals(obj)
      yield {
        MethodName = "Equals"
        Modifiers = [|"public"; "override"|]
        Type = "bool"
        Parameters = [|{ParameterName = "obj"; Type = "object"}|]
        Statements =
          [|
            match typeKind with
            | Class ->
              yield sprintf "return Equals(obj as %s);" selfType
            | Struct ->
              yield sprintf "return obj is %s && Equals((%s)obj);" selfType selfType
          |]
      }
      // Equals(Self)
      yield {
        MethodName = "Equals"
        Modifiers = [|"public"|]
        Type = "bool"
        Parameters = [|{ParameterName = "other"; Type = selfType}|]
        Statements =
          [|
            if typeKind = TypeKind.Class then
              yield "if (ReferenceEquals(this, other)) return true;"
              yield "if (ReferenceEquals(other, null)) return false;"
            let equation field =
              sprintf "%s == other.%s" field.FieldName field.FieldName
            if fields |> Array.length = 1 then
              yield sprintf "return %s;" (equation fields.[0])
            else
              yield sprintf "return %s" (equation fields.[0])
              for (i, field) in fields |> Seq.indexed |> Seq.skip 1 do
                let semicolon = if i = fields.Length - 1 then ";" else "";
                yield sprintf "    && %s%s" (equation field) semicolon
          |]
      }
      // GetHashCode()
      yield {
        MethodName = "GetHashCode"
        Modifiers = [|"public"; "override"|]
        Type = "int"
        Parameters = [||]
        Statements =
          [|
            // FIXME: xor is bad
            sprintf "return %s;" (fields |> Array.map (fun field -> "Dgh.Hash(" + field.FieldName + ")") |> String.concat " ^ ")
          |]
      }
      // operator ==/!=
      for (name, expr) in [|("operator ==", "l.Equals(r)"); ("operator !=", "!(l == r)")|] do
        yield {
          MethodName = name
          Modifiers = [|"public"; "static"|]
          Type = "bool"
          Parameters = [|param "l" selfType; param "r" selfType|]
          Statements = [|sprintf "return %s;" expr|]
        }
    |]

module ConfigParsing =

  module G = CodeGeneration

  // FIXME: Separate code generation from decode.
  let parseInput j =
    let decodeFieldModel =
      JD.propertyListWith JD.string
      |> CD.map
        (fun fields ->
          [|
            for (fieldName, ty) in fields |> List.rev ->
              ({
                FieldName = fieldName
                Type = ty
                Modifiers = [|"public"; "readonly"|]
              }: G.FieldModel)
          |])

    let decodeClassModelContent =
      jsonDecoder {
        let! kind =
          JD.optional "kind"
          |> CD.map
            (function
            | Some "struct" ->
              G.Struct
            | Some "class"
            | None ->
              G.Class
            | Some value ->
              failwithf "Unknown kind: %s." value
            )
        let! derives =
          JD.optionalArray JD.stringArray "derive"
          |> CD.map set
        let! fields =
          JD.required "fields"
          |> CD.compose decodeFieldModel
        let modifiers =
          [|
            yield "public"
            if kind = G.Class then
              yield "sealed"
            yield "partial"
          |]
        return (kind, modifiers, derives, fields)
      }

    let decodeNamespaceModel =
      JD.propertyListWith decodeClassModelContent
      |> CD.map
        (fun classes ->
        [|
          for (className, (kind, modifiers, derives, fields)) in classes |> List.rev do
            let deriveEq = derives |> Set.contains "?Eq" |> not
            let methods =
              [|
                yield CodeGeneration.generateCompleteConstructor className fields
                if deriveEq then
                  yield! CodeGeneration.generateEquality className kind fields
                if derives |> Set.contains "?ToString" |> not then
                  yield! CodeGeneration.generateToString className fields
              |]
            let baseType =
              if deriveEq then sprintf "IEquatable<%s>" className |> Some else None
            yield
              ({
                ClassName = className
                Kind = kind
                Modifiers = modifiers
                BaseType = baseType
                Fields = fields
                Methods = methods
              }: G.ClassModel)
        |])

    let rec decode = jsonDecoder {
      let! usings =
        JD.optionalArray JD.stringArray "usings"
      let! types =
        JD.required "types"
        |> CD.compose (JD.propertyListWith decodeNamespaceModel)
        |> CD.map
          (fun namespaces ->
            [|
              for (namespaceName, classes) in namespaces |> List.rev ->
                ({
                  NamespaceName = namespaceName
                  Classes = classes
                }: G.NamespaceModel)
            |])
      return
        ({
          Usings = usings
          Namespaces = types
        }: G.ModuleModel)
    }

    Json.parse j
    |> JsonResult.bind decode

let render (model: CodeGeneration.ModuleModel) =
  let template = DotLiquid.Template.Parse(templateSource)
  let local = DotLiquidHelper.LocalFromJson(model.ToJson())
  template.Render(local)

let generate (sourceJson: string) =
  ConfigParsing.parseInput sourceJson
  |> JsonResult.map render
  |> JsonResult.toResult
